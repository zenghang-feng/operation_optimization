# 1. 问题描述

利用一块长宽分别为40、30厘米的纸板，制作一个无盖的立体纸盒。在四个角分别剪下四个正方形，  

然后折起四个侧面使其与底面垂直，用胶带固定住，设计师希望纸盒的体积尽可能大。  

对问题的分析和建模如下图所示：  

![i](https://github.com/zenghang-feng/operation_optimization/blob/main/03-非线性规划-纸盒体积/pic1.png)

采用 **模拟退火算法** 求解此问题 

# 2. 程序实现

```
import numpy as np

#################################################################
# 定义优化目标: maximize obj: (40-2*x) * (30-2*x) * x
#################################################################
# 目标函数化简之后：f = 4 * x**3 - 140 * x**2 + 1200 * x
def f(x):
    return 4 * x ** 3 - 140 * x ** 2 + 1200 * x


#################################################################
# 模拟退火算法 ====================================================
#################################################################
# 定义算法相关的超参数 =============================================
T_start = 100
T_end = 1
L_at_T = 100
r_atten = 0.998
k = 1

# 初始化自变量，是0-15区间随机一个数值 ================================
x = 15 * np.random.rand()
# 初始化温度，取值为T_start =========================================
T = T_start

# 算法开始迭代 =====================================================
while T > T_end:
    for i in range(L_at_T):
        x_new = x + np.random.uniform(low=-1, high=1, size=1)[0]
        if 0 < x_new < 15:                                          # 判断新生成自变量的范围
            f_dif = f(x_new) - f(x)                                 # 判断新旧两个状态对应的函数值
            if f_dif > 0:                                           # 求解的是最大化问题，所以新值大于旧值继续迭代
                x = x_new
            else:
                p_de = np.exp(f_dif/(k*T))                          # 新函数值小于旧函数值，按照降温概率p_de和0到1之间随机值比较，以一定概率迭代
                if p_de > np.random.rand():
                    x = x_new
                else:
                    pass
        else:
            pass
    T = T * r_atten                                                 # 温度下降

print("最优解对应的x", x, "最优解", f(x))
```

打印输出如下：

```
最优解对应的x 5.656007001704872 最优解 3032.302323089036
```

