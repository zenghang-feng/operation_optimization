# 1. 问题描述
## 1.1 描述

利用一块长宽分别为40、30厘米的纸板，制作一个无盖的立体纸盒。在四个角分别剪下四个正方形，  

然后折起四个侧面使其与底面垂直，用胶带固定住，设计师希望纸盒的体积尽可能大。  

对问题的分析和建模如下图所示：  

![i](https://github.com/zenghang-feng/operation_optimization/blob/main/03-非线性规划-纸盒体积/pic1.png)


## 1.2 求解分析：  

目标函数是单变量3次函数，我们可以求目标函数的一阶导数，找到一阶导数函数对应的零点，进而确定极值；  

因为约束条件实际上只有 0< x <15, 我们也可以模拟梯度下降法进行求解，下文程序就按照这个思路实现。  

确定起始点的时候，我们选择0-15之间的任意一个数值，  


# 2. 程序实现

```
import numpy as np
import matplotlib.pyplot as plt


#################################################################
# 定义优化目标: maximize obj: (40-2*x) * (30-2*x) * x
#################################################################
# 目标函数化简之后：f = 4 * x**3 - 140 * x**2 + 1200 * x
def f(x):
    return 4 * x ** 3 - 140 * x ** 2 + 1200 * x


# 绘制0-15区间内的图像 =============================================
list_x = np.linspace(start=0, stop=15, num=100)
list_y = []
for x in list_x:
    list_y.append(f(x))

# 绘制pdf的图像
fig, ax = plt.subplots()
ax.grid(True)  # 设置图像背景中的网格
ax.plot(list_x, list_y)
plt.show()


#################################################################
# 求一阶导数为0的解，用于验证
#################################################################
def solve_quadratic_with_numpy(a, b, c):
    """
    :param a: 二次项系数
    :param b: 一次项系数
    :param c: 常数项系数
    :return: 根
    """
    coefficients = [a, b, c]
    rs = np.roots(coefficients)
    return rs


roots = solve_quadratic_with_numpy(a=12, b=-280, c=1200)

#################################################################
# 模拟梯度下降求解，我们这里是求最大，所以后续对自变量迭代的时候是做加法！！！
#################################################################
# 定义自变量初始值 ================================================
x = 9
# 初始化一阶导数迭代前后的差值，用于判断是否终止算法======================
f_dif = 100
# 求解误差，用于判断是否终止算法======================================
error = 0.0001
# 学习率 =========================================================
lr = 0.01
# 进行循环迭代 ====================================================
while f_dif > error and 0 < x < 15:
    f_1 = 12 * x ** 2 - 280 * x + 1200
    x_new = x + lr * f_1  # 注意这里是加法!!!!!!
    f_dif = f(x_new) - f(x)
    x = x_new

print("极值点对应自变量取值", roots)
print("模拟梯度下降得到最优解对应的x", x, "模拟梯度下降得到最优解", f(x))

```

输出函数f(x)在0-15区间的函数图像如下：

![i](https://github.com/zenghang-feng/operation_optimization/blob/main/03-非线性规划-纸盒体积/pic2.png)

打印的最优解如下：
```
极值点对应自变量取值 [17.67591879  5.65741454]
模拟梯度下降得到最优解对应的x 5.657880303363209 模拟梯度下降得到最优解 3032.3024503211645
```

将求得的5.65的左右两侧的自变量，带入目标函数一阶导数，可以判断我们得到的是0-15之间的极大值。
