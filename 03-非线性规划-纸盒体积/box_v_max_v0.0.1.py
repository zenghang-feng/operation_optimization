import numpy as np

""""""


#################################################################
# 求一阶导数为0的解，用于验证
#################################################################
def solve_quadratic_with_numpy(a, b, c):
    """
    :param a: 二次项系数
    :param b: 一次项系数
    :param c: 常数项系数
    :return: 根
    """
    coefficients = [a, b, c]
    rs = np.roots(coefficients)
    return rs


roots = solve_quadratic_with_numpy(a=12, b=-280, c=1200)


#################################################################
# 模拟梯度下降求解，我们这里是求最大，所以后续对自变量迭代的时候是做加法！！！
#################################################################
# 定义优化目标: maximize obj: (40-2*x) * (30-2*x) * x
# 目标函数化简之后：f = 4 * x**3 - 140 * x**2 + 1200 * x
def f(x):
    return 4 * x ** 3 - 140 * x ** 2 + 1200 * x

# 定义自变量初始值 ================================================
x = 9
# 初始化一阶导数迭代前后的差值，用于判断是否终止算法======================
f_dif = 100
# 求解误差，用于判断是否终止算法======================================
error = 0.0001
# 学习率 =========================================================
lr = 0.01
# 进行循环迭代 ====================================================
while f_dif > error and 0 < x < 15:
    f_1 = 12 * x ** 2 - 280 * x + 1200
    x_new = x + lr * f_1                    # 注意这里是加法!!!!!!
    f_dif = f(x_new) - f(x)
    x = x_new

print("极值点对应自变量取值", roots)
print("模拟梯度下降得到最优解对应的x", x, "模拟梯度下降得到最优解", f(x))
